#!/usr/bin/env python

import os
from os import path
from pathlib import Path
from urllib.parse import urlparse
import argparse
import csv
#import numpy as np
import math
import random
from datetime import datetime, timedelta
import sqlite3
import json
from collections import namedtuple
#import requests
import shortuuid
import time

from sqlalchemy import create_engine, and_, or_
from sqlalchemy.orm import Session, joinedload

import model
from lib import random_dates, SQL

from decimal import Decimal

#import logging
#logging.basicConfig()
#logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

ENTITY = {
    'asset': model.Asset,
    'market': model.Market,
    'account': model.Account
}

API_ENTITIES = {}

DATA_DIR = 'data'

CSV_OPTS = { 'delimiter': ',', 'quotechar': '"', 'quoting': csv.QUOTE_MINIMAL }

class Main():

    def __init__(self):

        self.engine = create_engine('sqlite:///mockex.db')
        self.session = Session(self.engine)

        parser = argparse.ArgumentParser(description='Import utility')
        parser.add_argument("action", choices=[
            'import', 'export',

            'events',  # process events, run daemon
                        # option: -daemon
                       # place-order
                       # cancel-order
                       # deposit
                       # withdraw
            'static_ohlc', # process to generate static ohlc data
                        # option: -daemon
            
            # events
            # orders (event) [source of book]
            # trades (order) [source of trades]
            # ledger (trade, deposit, withdraw)

            # Generate
            # take a list of trades: datetime,amount,price
            # to seed orders?

            'randbook', 'trade',

            # sql
            'book',

        ], help="Action")

        parser.add_argument("--entity",  help="entity")

        self.args = parser.parse_args()
        #print(self.args)
        getattr(self, 'cmd_' + self.args.action)()
    

    def cmd_book(self):
        sql = SQL['book']

        con = self.engine.connect()
        rs = con.execute(sql, (1,1,))
        print("%-10s %10s %10s %10s" % (
        'Side', 'Price','Amount','Total'))

        for row in rs:
            print("%-10s %10.2f %10.2f %10.2f" % tuple(row))



    def cmd_export(self):
        ser = ENTITY.keys() if 'all' == self.args.entity else [self.args.entity]
        for e in ser:
            print('Export',e,'.. ', end='')
            Entity = ENTITY[e]
            q = self.session.query(Entity)
            file = DATA_DIR + '/' + e + '.csv'
            with open(file, 'w') as csvfile:
                writer = csv.writer(csvfile, **CSV_OPTS)
                header = Entity.__table__.columns.keys()

                writer.writerow(header)
                
                cnt = 0
                for record in q.all():
                    writer.writerow([getattr(record, c) for c in header ])
                    cnt += 1
                print(cnt, 'rows')


    def cmd_import(self):
        ser = ENTITY.keys() if 'all' == self.args.entity else [self.args.entity]
        for e in ser:
            print('Import',e,'.. ', end='')
            Entity = ENTITY[e]
            file = DATA_DIR + '/' + e + '.csv'
            with open(file) as csvfile:
                reader = csv.DictReader(csvfile, **CSV_OPTS)

                # Clean table
                deleted = self.session.query(Entity).delete()
                self.session.commit()

                cnt = 0
                for row in reader:
                    self.session.add(Entity(**row))
                    cnt += 1
                self.session.commit()
                print(cnt, 'rows imported')


    def cmd_trade(self):
        file = DATA_DIR + '/bitmex_trades_2020-04-01_XBTUSD.csv'
        with open(file) as csvfile:
            reader = csv.DictReader(csvfile, **CSV_OPTS)

            # Clean table
            #deleted = self.session.query(model.Trade).delete()
            #self.session.commit()
            
            begin_row = 200000
            end_cnt = 50000

            start = datetime.utcnow() - timedelta(days=120)
            dt = start
            cnt = 0
            inserted = 0
            for row in reader:
                cnt += 1

                # skip some
                if cnt < begin_row:
                    continue
                if cnt > begin_row + end_cnt:
                    break

                ts = int(row['timestamp'])
                ts = ts / 1000000
                #dt = datetime.utcfromtimestamp(ts)
                #dt = dt.replace(2020, 5, 15)
                dt = dt + timedelta(minutes=5)
                #print(dt)
                price = Decimal(row['price'])
                amount = int(row['amount'])
                m = model.Trade(
                    account_id=100,
                    market_id=1,
                    created=dt,
                    price=price,
                    amount=amount
                )
                #print(m.__dict__)
                self.session.add(m)
                inserted += 1
                if cnt % 1000 == 0:
                    self.session.commit()

            self.session.commit()
            print(inserted, 'rows imported')


    def cmd_randbook(self):
        market = 1
        market_rate = 8800

        account = []
        account_idx = {}
        for o in self.session.query(model.Account).all():
            account_idx[o.id] = o.name
            account.append(o.id)

        assets = {
            'usd': {
                'issue': 100000000,
                'id': 1
            },
            'btc': {
                'issue': 50000,
                'id': 2
            }
        }

        """
        # Delete first
        self.session.query(model.Account).delete()
        self.session.commit()

        # Create accounts for all accounts.
        # Set initial balance from pareto distribution of issue amount.
        shape = 5
        size = len(account)
        dist = np.random.pareto(shape, size)

        dist_sum = sum(dist)
        for i, d in enumerate(dist):
            dist_rate =  d / dist_sum
            
            for asset in assets.keys():
                bal = assets[asset]['issue'] * dist_rate
                bal = math.ceil(bal)
                idx = assets[asset]['id']
                a = model.Account(account=account[i], asset=idx, balance=bal)
                self.session.add(a)

        self.session.commit()
        """
        
        print('random dates:')
        dates = random_dates(10000)
        
        """
        ass = {}
        for i in dates:
            match = 'DUP' if i in ass else ''
            ass[i] = 1
            print(i, match)
        return
        """
        # Create orders

        # Delete first
        #self.session.query(model.Order).delete()
        #self.session.commit()


        q = self.session.query(model.Account)
        cnt = 0
        for r in q.filter(model.Account.asset==1):
            print(r.__dict__)
            price = random.randrange(8801,9200)
            #price = random.randrange(8400,8800)
            #amt = r.balance / price 
            o = model.Order(
                created=dates[cnt],
                market=1,
                account=r.account,
                price=price,
                direction="sell",
                #direction="buy",
                amount=r.balance,
                amount_left=r.balance
                #amount=amt,
                #amount_left=amt
            )
            print(o.__dict__)
            #break
            self.session.add(o)
            if cnt % 100 == 0:
                print('commit()')
                self.session.commit()
            cnt += 1

        self.session.commit()

    def event_place_order(self, e):
        # event add_order
        #if e.action == 'ao':
        #    self.add_order()
        o = json.loads(e.body, object_hook=lambda d: namedtuple('X', d.keys())(*d.values()))
        demand = Decimal(o.amount)

        # Where
        where = []
        order = []

        where.append(model.Order.status.in_(['open','partial']))

        # NO WASH TRADES
        # Exclude account's orders from set to be matched
        where.append(model.Order.account_id != o.account_id)

        if o.side == 'sell':
            where.append(model.Order.side == 'buy')
            where.append(model.Order.price >= o.price)

            order.append(model.Order.price.desc())
            order.append(model.Order.id.asc())

        elif o.side == 'buy':
            where.append(model.Order.side == 'sell')
            where.append(model.Order.price <= o.price)

            order.append(model.Order.price.asc())
            order.append(model.Order.id.asc())

        # This query returns book matches, so start slicing thru them
        q2 = self.session.query(
            model.Order
        ).filter(
            and_(*where)
        ).order_by(
            *order
        )
        for o2 in q2.all():
            print("  > %05d %8s %8s %-4s %10d %10d [ %10d ]" % (
            o2.id, o2.type, o2.status, o2.side, o2.balance, o2.price, demand))
            # demand 3
            # has 2: tx for 2, 3-2, 1 demand left
            # has 12: tx for 1, 1-1, 0 demand left
            
            # tx is up to demand amt
            if not demand:
                break
            
            tx_amt = o2.balance if demand > o2.balance else demand
            demand -= tx_amt
            xx = model.Ledger(
                account_id=1,
                amount=tx_amt
            )
            print(xx.__dict__)
            self.session.add(xx)

            yy = model.Trade(
                account_id=1,
                market_id=1,
                price=o2.price,
                amount=tx_amt
            )
            self.session.add(yy)

            # then update remaining order amount
            o2.balance = o2.balance - tx_amt
            o2.status = self.get_status(o2)
            print("  X %05d %8s %8s %-4s %10d %10d [ %10d ]" % (
            o2.id, o2.type, o2.status, o2.side, o2.balance, o2.price, demand))
            print()
        

        if Decimal(demand) == Decimal(0):
            status = 'closed'
        elif Decimal(demand) != Decimal(o.amount):
            status = 'partial'
        else:
            status = 'open'

        no2 = model.Order(
            account_id=o.account_id,
            market_id=o.market_id,
            side=o.side,
            type='limit',
            price=o.price,
            amount=o.amount,
            balance=demand,
            status=status,
            event_uuid=e.uuid
        )
        #no.status = self.get_status(no)
        self.session.add(no2)

        print("new order:")
        print(no2.__dict__)

        e.status = 'done'
        #print("-d- %05d %8s %8s %-4s %10d %10d" % (
        #o.id, o.type, o.status, o.direction, o.amount_left, o.price))
        #print("%05d %s %8d %5s %s" % (
        #e.id, e.created, e.account, e.action, e.payload))

        self.session.commit()


    def event_cancel_order(self, e):
        p = json.loads(e.body)
        event_uuid = p['event_uuid']
        o = self.session.query(model.Order).filter_by(
            event_uuid=event_uuid).one_or_none()
        print(o.__dict__)
        o.status = 'canceled'

        e.status = 'done'
        self.session.commit()

    def event_deposit(self, e):
        p = json.loads(e.body)

        l = model.Ledger(
            account_id=p['account_id'],
            asset_id=p['asset_id'],
            amount=p['amount']
        )
        self.session.add(l)
        e.status = 'done'
        self.session.commit()

    def event_withdraw(self, e):
        p = json.loads(e.body)

        l = model.Ledger(
            account_id=p['account_id'],
            asset_id=p['asset_id'],
            amount=p['amount'] * -1
        )
        self.session.add(l)
        e.status = 'done'
        self.session.commit()


    def cmd_events(self):
        print('Process events..')

        # 1. Foreach order with new status
        #   a. For limit
        #       A. Foreach order where()  orderby(price)
        #  opposite direction (buy vs sell)
        #  and price <=> our price

        q = self.session.query(
            model.Event
        ).filter_by(
            status='new'
        ).order_by(model.Event.id)

        for e in q.all():
            print("%05d %s %8s\n%s" % (
            e.id, e.created, e.method, e.body))
            #o = json.loads(e.payload)
            #o = type("JSON", (), json.loads(e.payload))()

            if e.method == 'deposit':
                self.event_deposit(e)
            elif e.method == 'withdraw':
                self.event_withdraw(e)
            elif e.method == 'cancel-order':
                self.event_cancel_order(e)
            elif e.method == 'place-order':
                self.event_place_order(e)


    def get_status(self, obj):
        if obj.balance == 0:
            return 'closed'
        elif obj.balance != obj.amount:
            return 'partial'
        else:
            return 'open'


if __name__ == '__main__':
    Main()




