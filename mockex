#!/usr/bin/env python

import os
from os import path
from pathlib import Path
from urllib.parse import urlparse
import argparse
import csv
#import numpy as np
import math
import random
from datetime import datetime, timedelta
import sqlite3
import json
from collections import namedtuple
#import requests
import shortuuid
import time

from sqlalchemy import create_engine, and_, or_, func
from sqlalchemy.orm import Session, joinedload

import model
from model import (Account, Market, Asset, Event, Order, Trade, Ledger)
from lib import random_dates, SQL, intervals, DT_FORMAT, TradeFile
from ohlc import OHLC


from decimal import Decimal

import arrow

#import logging
#logging.basicConfig()
#logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

ENTITY = {
    'asset': model.Asset,
    'market': model.Market,
    'account': model.Account
}

API_ENTITIES = {}

DATA_DIR = 'data'

CSV_OPTS = { 'delimiter': ',', 'quotechar': '"', 'quoting': csv.QUOTE_MINIMAL }



class Main():

    def __init__(self):

        self.engine = create_engine('sqlite:///mockex.db')
        self.session = Session(self.engine)

        parser = argparse.ArgumentParser(description='Import utility')
        parser.add_argument("action", choices=[
            'maker',
            # maker
            #    --speed 1m
            #    --volume 1k
            #    --pattern [daytime, weekends]
            #    --source TRADES_FILE

            'import', 'export',

            'ohlc',
            'fake',

            'events',  # process events, run daemon
                        # option: -daemon
                       # place-order
                       # cancel-order
                       # deposit
                       # withdraw
            'static_ohlc', # process to generate static ohlc data
                        # option: -daemon
            
            # events
            # orders (event) [source of book]
            # trades (order) [source of trades]
            # ledger (trade, deposit, withdraw)

            # Generate
            # take a list of trades: datetime,amount,price
            # to seed orders?

            'randbook', 'trade',

            # sql
            'book',

        ], help="Action")

        parser.add_argument("--entity",  help="entity")

        # For ohlc
        parser.add_argument('-s', "--stream",  action='store_true')
        parser.add_argument('-m', "--market")

        self.args = parser.parse_args()
        #print(self.args)
        getattr(self, 'cmd_' + self.args.action)()
    

    def cmd_ohlc(self):
        print('make static ohlc')
        
        OHLC(self.session).generate_cache(self.args.market, self.args.stream)

    def cmd_fake(self):
        print('fake history')

        # book
        # let's try running actual trades and see what happens

        # delete orders
        # delete trades
        db = self.session
        
        market_id = 3
        account_id = 100

        db.query(Order).filter_by(market_id=market_id).delete()
        db.query(Trade).filter_by(market_id=market_id).delete()
        db.commit()


        file = DATA_DIR + '/bitmex_trades_2020-04-01_XBTUSD.csv'
        with open(file) as csvfile:
            reader = csv.DictReader(csvfile, **CSV_OPTS)

            begin_row = 200000
            end_cnt = 150000

            start = datetime.utcnow() - timedelta(days=2)
            dt = start
            cnt = 0
            inserted = 0
            for row in reader:
                cnt += 1

                # skip some
                #if cnt < begin_row:
                #    continue
                #if cnt > begin_row + end_cnt:
                #    break

                ts = int(row['timestamp'])
                ts = ts / 1000000
                
                dt = datetime.utcfromtimestamp(ts)
                dt = dt.replace(2020, 5, 29)
                #dt = dt + timedelta(minutes=5)
                #print(dt)
                price = float(row['price'])
                amount = int(row['amount'])
                side = row['side']
                """
                m = model.Trade(
                    account_id=account_id,
                    market_id=market_id,
                    created=dt,
                    price=price,
                    amount=amount
                )
                """
                m = Event(
                    method='place-order',
                    account_id=account_id,
                    created=dt,
                    body=json.dumps({
                        'price': price,
                        'amount': amount,
                        'market_id': market_id,
                        'account_id': account_id,
                        'side': side
                    })
                )
                #print(m.__dict__)
                self.session.add(m)
                inserted += 1
                if cnt % 1000 == 0:
                    print("commit ",cnt, dt)
                    self.session.commit()

            self.session.commit()
            print(inserted, 'rows imported')


    def cmd_maker(self):
        print('Fake market maker')
        
        db = self.session

        market = db.query(Market).filter_by(
            name='SHTUSD').one_or_none()

        while True:
            # TODO: Change to order by created.desc()
            last_trade = db.query(Trade).filter_by(
                market_id=market.id).order_by(Trade.id.desc()).first()
            last_price = 12
            if (last_trade):
                last_price = last_trade.price

            account_id = random.randrange(1000000,5000000)
            side = random.choice(['buy', 'sell'])
            #price = abs(last_price + random.randrange(-100,100))
            price = abs(float(last_price) + random.uniform(-2,4))
            amount = random.uniform(1,30)
            e = model.Event(
                account_id=account_id,
                method='place-order',
                body=json.dumps({
                    'account_id': account_id,
                    'market_id': market.id,
                    'price': float(price),
                    'amount': amount,
                    'side': side
                })
            )
            print("%s %s %s @ %s" % (e.method, side, amount, price))
            self.session.add(e)
            self.session.commit()

            seconds = random.uniform(.1,1)
            print("Sleep %s seconds.." % (seconds,))
            time.sleep(seconds)


    def cmd_book(self):
        sql = SQL['book']

        con = self.engine.connect()
        rs = con.execute(sql, (1,1,))
        print("%-10s %10s %10s %10s" % (
        'Side', 'Price','Amount','Total'))

        for row in rs:
            print("%-10s %10.2f %10.2f %10.2f" % tuple(row))



    def cmd_export(self):
        ser = ENTITY.keys() if 'all' == self.args.entity else [self.args.entity]
        for e in ser:
            print('Export',e,'.. ', end='')
            Entity = ENTITY[e]
            q = self.session.query(Entity)
            file = DATA_DIR + '/' + e + '.csv'
            with open(file, 'w') as csvfile:
                writer = csv.writer(csvfile, **CSV_OPTS)
                header = Entity.__table__.columns.keys()

                writer.writerow(header)
                
                cnt = 0
                for record in q.all():
                    writer.writerow([getattr(record, c) for c in header ])
                    cnt += 1
                print(cnt, 'rows')


    def cmd_import(self):
        ser = ENTITY.keys() if 'all' == self.args.entity else [self.args.entity]
        for e in ser:
            print('Import',e,'.. ', end='')
            Entity = ENTITY[e]
            file = DATA_DIR + '/' + e + '.csv'
            with open(file) as csvfile:
                reader = csv.DictReader(csvfile, **CSV_OPTS)

                # Clean table
                deleted = self.session.query(Entity).delete()
                self.session.commit()

                cnt = 0
                for row in reader:
                    self.session.add(Entity(**row))
                    cnt += 1
                self.session.commit()
                print(cnt, 'rows imported')


    def cmd_trade(self):
        file = DATA_DIR + '/bitmex_trades_2020-04-01_XBTUSD.csv'
        with open(file) as csvfile:
            reader = csv.DictReader(csvfile, **CSV_OPTS)

            # Clean table
            #deleted = self.session.query(model.Trade).delete()
            #self.session.commit()
            
            begin_row = 200000
            end_cnt = 50000

            start = datetime.utcnow() - timedelta(days=120)
            dt = start
            cnt = 0
            inserted = 0
            for row in reader:
                cnt += 1

                # skip some
                if cnt < begin_row:
                    continue
                if cnt > begin_row + end_cnt:
                    break

                ts = int(row['timestamp'])
                ts = ts / 1000000
                #dt = datetime.utcfromtimestamp(ts)
                #dt = dt.replace(2020, 5, 15)
                dt = dt + timedelta(minutes=5)
                #print(dt)
                price = Decimal(row['price'])
                amount = int(row['amount'])
                m = model.Trade(
                    account_id=100,
                    market_id=1,
                    created=dt,
                    price=price,
                    amount=amount
                )
                #print(m.__dict__)
                self.session.add(m)
                inserted += 1
                if cnt % 1000 == 0:
                    self.session.commit()

            self.session.commit()
            print(inserted, 'rows imported')


    def cmd_randbook(self):
        market = 1
        market_rate = 8800

        account = []
        account_idx = {}
        for o in self.session.query(model.Account).all():
            account_idx[o.id] = o.name
            account.append(o.id)

        assets = {
            'usd': {
                'issue': 100000000,
                'id': 1
            },
            'btc': {
                'issue': 50000,
                'id': 2
            }
        }

        """
        # Delete first
        self.session.query(model.Account).delete()
        self.session.commit()

        # Create accounts for all accounts.
        # Set initial balance from pareto distribution of issue amount.
        shape = 5
        size = len(account)
        dist = np.random.pareto(shape, size)

        dist_sum = sum(dist)
        for i, d in enumerate(dist):
            dist_rate =  d / dist_sum
            
            for asset in assets.keys():
                bal = assets[asset]['issue'] * dist_rate
                bal = math.ceil(bal)
                idx = assets[asset]['id']
                a = model.Account(account=account[i], asset=idx, balance=bal)
                self.session.add(a)

        self.session.commit()
        """
        
        print('random dates:')
        dates = random_dates(10000)
        
        """
        ass = {}
        for i in dates:
            match = 'DUP' if i in ass else ''
            ass[i] = 1
            print(i, match)
        return
        """
        # Create orders

        # Delete first
        #self.session.query(model.Order).delete()
        #self.session.commit()


        q = self.session.query(model.Account)
        cnt = 0
        for r in q.filter(model.Account.asset==1):
            print(r.__dict__)
            price = random.randrange(8801,9200)
            #price = random.randrange(8400,8800)
            #amt = r.balance / price 
            o = model.Order(
                created=dates[cnt],
                market=1,
                account=r.account,
                price=price,
                direction="sell",
                #direction="buy",
                amount=r.balance,
                amount_left=r.balance
                #amount=amt,
                #amount_left=amt
            )
            print(o.__dict__)
            #break
            self.session.add(o)
            if cnt % 100 == 0:
                print('commit()')
                self.session.commit()
            cnt += 1

        self.session.commit()

    def event_place_order(self, e):
        # event add_order
        #if e.action == 'ao':
        #    self.add_order()
        o = json.loads(e.body, object_hook=lambda d: namedtuple('eventBody', d.keys())(*d.values()))
        demand = Decimal(o.amount)

        market = self.markets[o.market_id]

        # Where
        where = []
        order = []

        where.append(model.Order.market_id == o.market_id)

        where.append(model.Order.status.in_(['open','partial']))

        # NO WASH TRADES
        # Exclude account's orders from set to be matched
        where.append(model.Order.account_id != o.account_id)


        if o.side == 'sell':
            where.append(model.Order.side == 'buy')
            where.append(model.Order.price >= o.price)

            order.append(model.Order.price.desc())
            order.append(model.Order.id.asc())

        elif o.side == 'buy':
            where.append(model.Order.side == 'sell')
            where.append(model.Order.price <= o.price)

            order.append(model.Order.price.asc())
            order.append(model.Order.id.asc())

        # This query returns book matches, so start slicing thru them
        q2 = self.session.query(
            model.Order
        ).filter(
            and_(*where)
        ).order_by(
            *order
        )
        for o2 in q2.all():
            print("  > %05d %8s %8s %-4s %10d %10d [ %10d ] %s" % (
            o2.id, o2.type, o2.status, o2.side, o2.balance, o2.price, 
            demand, o2.market_id))
            # demand 3
            # has 2: tx for 2, 3-2, 1 demand left
            # has 12: tx for 1, 1-1, 0 demand left
            
            # tx is up to demand amt
            if not demand:
                break
            
            tx_amt = o2.balance if demand > o2.balance else demand
            tx_total = tx_amt * o2.price
            demand -= tx_amt


            # TODO: 2 Ledger entries for each side of the trade
            # o.type == 'sell'
            # asset1 -amount o.account_id (me)
            # asset1 +amount o2.account_id (buyer)
            # uoa    -amount o2.account_id (buyer)
            # uoa    +amount o.account_id (me)

            # o.type == 'buy'
            # asset1 -amount o2.account_id (seller)
            # asset1 +amount o.account_id (me)
            # uoa    -amount o.account_id (me)
            # uoa    +amount o2.account_id (seller)
            
            buyer_id  = o.account_id if o.side == 'buy' else o2.account_id
            seller_id = o.account_id if o.side == 'sell' else o2.account_id

            bq = self.session.query(
                Ledger.account_id,
                Ledger.asset_id,
                func.sum(Ledger.amount).label('balance'),
            ).filter(
                Ledger.account_id.in_((buyer_id, seller_id)),
                Ledger.asset_id.in_((market.asset.id, market.uoa.id))
            ).group_by(Ledger.account_id, Ledger.asset_id)

            bal = {}
            for b in bq.all():
                if b.asset_id not in bal:
                    bal[b.asset_id] = {}
                bal[b.asset_id][b.account_id] = b.balance

            """
            sht eric -amt   sht.eric.bal + -amt
            sht joe   amt   sht.joe.bal  +  amt
            usd joe  -amt   usd.joe.bal  + -amt
            usd eric  amt   usd.eric.bal +  amt
            """

            keys = ['asset_id','account_id','amount']
            ledgers = [
                (market.asset.id,  seller_id, tx_amt * -1),
                (market.asset.id,  buyer_id,  tx_amt),
                (market.uoa.id,    buyer_id,  tx_total * -1),
                (market.uoa.id,    seller_id, tx_total)
            ]
            
            print("Ledgers")
            for values in ledgers:
                l = Ledger(**dict(zip(keys, values)))
                if l.asset_id in bal and l.account_id in bal[l.asset_id]:
                    l.balance = bal[l.asset_id][l.account_id] + l.amount
                self.session.add(l)
                
                lout = dict(l.__dict__)
                lout.pop('_sa_instance_state', None)
                print(lout)

            """
            OrderA        OrderB
             \              /
              --------------
                    |
                   / \
             TradeA   TradeB
                   \ /
                    |
                  Trade (anonymous)

                        TradeAccount(
                            trade_id   =
                            account_id = 
                            asset_id   =
                            amount     =
                        )

            Eric sells 2 BTC to Shawn @ $8,000, total $16,000


            Shawn buys 2 BTC from Shawn @ $8,000, total $16,000


            """

            yy = model.Trade(  # Anonymous
                account_id  = o.account_id,
                market_id   = market.id,
                price       = o2.price,
                amount      = tx_amt,
                created     = e.created
            )
            self.session.add(yy)
            self.tf.append(market, ','.join([
                yy.created.strftime(DT_FORMAT),
                "%.10f" % yy.price,
                "%.10f" % yy.amount
            ]))
            # then update remaining order amount
            o2.balance = o2.balance - tx_amt
            o2.status = self.get_status(o2)
            print("  X %05d %8s %8s %-4s %10d %10d [ %10d ]" % (
            o2.id, o2.type, o2.status, o2.side, o2.balance, o2.price, demand))
            print()
        

        if Decimal(demand) == Decimal(0):
            status = 'closed'
        elif Decimal(demand) != Decimal(o.amount):
            status = 'partial'
        else:
            status = 'open'

        no2 = model.Order(
            account_id=o.account_id,
            market_id=o.market_id,
            side=o.side,
            type='limit',
            price=o.price,
            amount=o.amount,
            balance=demand,
            status=status,
            uuid=e.uuid,
            created=e.created
        )
        #no.status = self.get_status(no)
        self.session.add(no2)

        print("new order:")
        print(no2.__dict__)

        e.status = 'done'
        #print("-d- %05d %8s %8s %-4s %10d %10d" % (
        #o.id, o.type, o.status, o.direction, o.amount_left, o.price))
        #print("%05d %s %8d %5s %s" % (
        #e.id, e.created, e.account, e.action, e.payload))

        #self.session.commit()


    def event_cancel_order(self, e):
        p = json.loads(e.body)
        uuid = p['uuid']
        o = self.session.query(model.Order).filter_by(
            uuid=uuid).one_or_none()
        print(o.__dict__)
        o.status = 'canceled'

        e.status = 'done'
        #self.session.commit()

    def event_deposit(self, e):
        p = json.loads(e.body)

        l = model.Ledger(
            account_id=p['account_id'],
            asset_id=p['asset_id'],
            amount=p['amount']
        )
        self.session.add(l)
        e.status = 'done'
        #self.session.commit()

    def event_withdraw(self, e):
        p = json.loads(e.body)

        l = model.Ledger(
            account_id=p['account_id'],
            asset_id=p['asset_id'],
            amount=p['amount'] * -1
        )
        self.session.add(l)
        e.status = 'done'
        #self.session.commit()


    def cmd_events(self):
        print('Process events..')

        # 1. Foreach order with new status
        #   a. For limit
        #       A. Foreach order where()  orderby(price)
        #  opposite direction (buy vs sell)
        #  and price <=> our price

        db = self.session

        q = db.query(Market).options(
            joinedload(Market.asset, innerjoin=True),
            joinedload(Market.uoa, innerjoin=True)
        )
        self.markets = {}

        for m in q.all():
            self.markets[m.id] = m

        self.tf = TradeFile()

        while True:

            begin = time.time()

            events = db.query(Event).filter_by(status='new').\
                order_by(Event.created.asc()).limit(1000)
            
            for e in events.all():
                print("%05d %s %8s\n%s" % (
                e.id, e.created, e.method, e.body))
                #o = json.loads(e.payload)
                #o = type("JSON", (), json.loads(e.payload))()

                # Event(e).execute()

                if e.method == 'deposit':
                    self.event_deposit(e)
                elif e.method == 'withdraw':
                    self.event_withdraw(e)
                elif e.method == 'cancel-order':
                    self.event_cancel_order(e)
                elif e.method == 'place-order':
                    self.event_place_order(e)
            
            db.commit()
            self.tf.commit()
            print("Took %f seconds. Sleep 2 seconds.." % (time.time() - begin))
            time.sleep(2)


    def get_status(self, obj):
        if obj.balance == 0:
            return 'closed'
        elif obj.balance != obj.amount:
            return 'partial'
        else:
            return 'open'


if __name__ == '__main__':
    Main()




